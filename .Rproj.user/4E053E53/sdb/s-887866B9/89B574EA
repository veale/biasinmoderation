{
    "collab_server" : "",
    "contents" : "require(tidyverse)\nrequire(boot)\ndat <- read.csv(\"classified_tweets_mi_fe_ma_old_young.csv\", stringsAsFactors = F)\ndat <- as_tibble(dat)\ndat$male_classes <- dat$male_classes %>% as.logical()\ndat$female_classes <- dat$female_classes %>% as.logical()\ndat$old_classes <- dat$old_classes %>% as.logical()\ndat$young_classes <- dat$young_classes %>% as.logical()\n\ntable(dat$female_classes)\n\nboo <- list()\nmean.fun <- function(dat, idx) {mean(dat[idx], na.rm = TRUE)}\nlibrary(snow)\nboo$male <- boot(dat$male_classes, \n                 R = 30000, \n                 statistic = mean.fun,\n                 parallel = \"snow\")\n\nboo$male.ci <- boot.ci(boo$male, type = c(\"norm\", \"basic\"), conf = 0.98)\n\n\nboo$old <- boot(dat$old_classes, \n                 R = 25000, \n                 statistic = mean.fun,\n                 parallel = \"snow\")\n\nboo$old.ci <- boot.ci(boo$old)\n\nboo$young <- boot(dat$young_classes, \n                R = 25000, \n                statistic = mean.fun,\n                parallel = \"snow\")\n\nboo$young.ci <- boot.ci(boo$young)\n\nboo$female <- boot(dat$female_classes, \n                  R = 25000, \n                  statistic = mean.fun,\n                  parallel = \"snow\")\n\nboo$female.ci <- boot.ci(boo$female)\n\n\nrequire(irr)\nrequire(boot)\nrequire(tidyverse)\ntox <- read_tsv(\"/Users/mv/Dropbox (Personal)/Make/Program/CSCW Automated Moderation/4563973/toxicity_annotated_comments.tsv\")\ntox.dem <- read_tsv(\"/Users/mv/Dropbox (Personal)/Make/Program/CSCW Automated Moderation/4563973/toxicity_worker_demographics.tsv\")\ntox.ann <- read_tsv(\"/Users/mv/Dropbox (Personal)/Make/Program/CSCW Automated Moderation/4563973/toxicity_annotations.tsv\")\n\ntox.ann %>% left_join(tox.dem) -> tox.long\ntox.long %>% filter(!is.na(gender)) %>% group_by(rev_id, gender) %>% count() \n\ntox.long %>% group_by(gender, rev_id) %>% count() -> tox.gender.rev\n\ntable(tox.gender.rev$n, tox.gender.rev$gender)\n\nggplot(tox.gender.rev, aes(y = n, group= gender, fill = gender)) + geom_bar(position =\"dodge\", stat = \"identity\")\n\ntox.long %>% filter(worker_id == 3603)\n\ntox.long %>% filter(!is.na(gender)) %>% \n  group_by(rev_id, gender) %>% \n  filter(n() > 1) %>%\n  mutate(mean.tox = round(mean(toxicity)), \n         dissenter = ifelse(toxicity != mean.tox, 1, 0)) %>%\n  summarise(dissent = sum(dissenter)/n()) -> tox.dissent\n\ntox.dissent %>% filter(gender == \"female\")  -> tox.dissent.f\ntox.dissent %>% filter(gender == \"male\")  -> tox.dissent.m\nlibrary(parallel)\ncl <- makeCluster(4)\n?parallel\n\nmean.fun <- function(dat, idx) {mean(dat[idx], na.rm = TRUE)}\nlibrary(snow)\nboo <- list()\nboo$fem <- boot(tox.dissent.f$dissent, \n                 R = 1000, \n                 statistic = mean.fun,\n                 parallel = \"multicore\")\nboo$fem.ci <- boot.ci(boo$fem, type = c(\"norm\", \"basic\"), conf = 0.98)\nboo$fem.ci\n\nboo$mal <- boot(tox.dissent.m$dissent, \n                R = 1000, \n                statistic = mean.fun,\n                parallel = \"multicore\")\nboo$mal.ci <- boot.ci(boo$mal, type = c(\"norm\", \"basic\"), conf = 0.98)\nboo$mal.ci\n\n  \n  summarise(mean.dissent = mean(dissent))\n\n# more likely to flag somethign that is offensive as not offensive\n# more likely to 'let things through' than to miss things out  \n2627/25506\n570/3163\n\n\ntox.long %>% \n  filter(gender == \"female\") %>% \n  select(rev_id, worker_id, toxicity) %>%\n  spread(rev_id, value = toxicity) -> mat\n\nmat <- as.matrix(mat)\n\n\n\nmatrix(c(1, 2, 3, 1, 2, 3, 3, 2, 3, 2, 2, 3, 3, 2, 1, 3, 1, 3), nrow = 6) -> mat\nkripp.alpha(mat[1:100, 1:100]) \nkra(t(mat[1:100, 1:100]), metric = \"nominal\")\n\n\n-> kripster\nkripster\n\nlibrary(rel)\nkrip.fem <- kra(mat[1:100, 1:100], metric = \"nominal\")\n\n\n\nlibrary(parallel)\ncl <- makeCluster(4)\n\n\n\"kra2\" <- \n  function(data = NULL, metric = c(\"nominal\",\"ordinal\",\"interval\",\"ratio\"), \n           conf.level = 0.95, R = 0) {\n    \n    cl <- match.call()\n    data <- as.matrix(data)\n    nr <- nrow(data)\n    nc <- ncol(data)\n    data <- matrix(as.numeric(as.factor(data)),nr,nc)\n    na <- sum(is.na(data))/(nr*nc)*100\n    \n    A <- function(data,metric){\n      \n      #Contingency table\n      mval <- max(data,na.rm=TRUE)\n      mu <- rowSums(!is.na(data))\n      ap <- expand.grid(seq_len(nc),seq_len(nc))\n      ap <- ap[ap[,1]!=ap[,2],]\n      \n      corr <- function(x){\n        tab <- quote(na.omit(table(data[x,ap[,1]],data[x,ap[,2]])/(mu[x]-1)))\n        mat <- matrix(0,mval,mval) \n        mat[as.numeric(rownames(eval(tab))),as.numeric(colnames(eval(tab)))] <- eval(tab) \n        return(mat)\n      }\n      mat <- Reduce(\"+\",lapply(X=1:nr,FUN=corr))\n      marg <- rowSums(mat)\n      \n      #Metrics\n      suppressWarnings(\n        if (metric == \"ratio\"){  \n          metric <- ( (row(mat)-col(mat))/(row(mat)+col(mat)) )^2\n          method = paste(\"Krippendorf's alpha for ratio data\")\n        } else if (metric == \"interval\"){\n          metric <- (row(mat)-col(mat))^2\n          method = paste(\"Krippendorf's alpha for interval data\")\n        } else if (metric == \"ordinal\"){\n          ends <- outer(marg,marg,\"+\")/2\n          ord <- function(x){\n            res <- matrix(0,mval,mval)\n            if (x<=mval-1){\n              res[x-1,(x+1):(mval)] <- t(matrix(cumsum(marg[(x):(mval-1)])))\n            }  else{\n              res <- ends\n            }\n            return(res)\n          }\n          cs <- Reduce(\"+\",lapply(X=2:(mval-1),FUN=ord))\n          metric <- (ifelse(col(cs)>row(cs)+1,cs+ends,ends))^2\n          metric[lower.tri(metric,diag=TRUE)] <- 0\n          metric <- metric+t(metric)\n          method = paste(\"Krippendorf's alpha for ordinal data\")\n        } else{\n          metric <- abs(diag(ncol(mat))-1)\n          method = paste(\"Krippendorf's alpha for nominal data\")\n        })\n      \n      #Point estimate\n      if (dim(mat)[1]==1 && dim(mat)[2]==1){\n        vs <- matrix(c(1,1),2,1)\n      } else {\n        vs <- combn(1:mval,2) \n      }\n      ka <- 1-(sum(marg)-1)*sum(mat[upper.tri(mat, diag = FALSE)]*metric[upper.tri(metric,diag=FALSE)])/\n        sum(marg[vs[1,]]*marg[vs[2,]]*t(metric[lower.tri(metric,diag=FALSE)]))\n      return(list(ka,method))\n    }\n    out <- A(data=data,metric=metric)\n    \n    #Bootstrapped confidence intervals\n    if (R == 0 || is.nan(out[[1]])){\n      res.boot <- c(NA,NA)\n    } else{\n      a <- unlist(lapply(X=1:R,function(x) A(data[sample(nr, replace=TRUE),], metric=metric)[[1]]))\n      res.boot <- quantile(x=a, probs=c((1-conf.level)/2,conf.level+(1-conf.level)/2), na.rm=TRUE) \n    }\n    out[is.nan(out[[1]])] <- 0\n    attr(res.boot,\"names\") <- \"Const\"\n    \n    res <- structure(list(method = out[[2]],\n                          call = cl,\n                          obs = nc,\n                          sample = nr,\n                          na = na,\n                          est = out[[1]],\n                          conf.level = conf.level,\n                          lb = res.boot[1],\n                          ub = res.boot[2],\n                          data = data),\n                     class = c(\"rel\",\"kra\"))\n    return(res)\n  }\n\n\n",
    "created" : 1493292251976.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2683182427",
    "id" : "89B574EA",
    "lastKnownWriteTime" : 1493372219,
    "last_content_update" : 1493372219050,
    "path" : "~/Dropbox (Personal)/Make/Program/CSCW Automated Moderation/cscwscript.R",
    "project_path" : "cscwscript.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}